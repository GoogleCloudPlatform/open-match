// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/protobuf-spec/frontend.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Frontend service

type FrontendClient interface {
	// CreateRequests will put the player (or group, if your 'Player'
	// message represents multiple players) in state storage, and then look
	// through the 'properties' field for the attributes you have defined as
	// indices your matchmaker config.  If the attributes exist and are valid
	// integers, they will be indexed.
	// INPUT: Player message with these fields populated:
	//  - id
	//  - properties
	// OUTPUT: Result message denoting success or failure (and an error if
	// necessary)
	CreateRequest(ctx context.Context, in *Player, opts ...grpc.CallOption) (*Result, error)
	// DeleteRequest removes the players (or group, if your 'Player'
	// message represents multiple players) from state storage by doing the
	// following:
	//  1) Delete player from configured indices.  This effectively removes the
	//     player from matchmaking when using recommended MMF patterns.
	//     Everything after this is just cleanup to save stage storage space.
	//  2) 'Lazily' delete the player's state storage record.  This is kicked
	//     off in the background and may take some time to complete.
	//  2) 'Lazily' delete the player's metadata indicies (like, the time they
	//     created the request, and the last time the record was accessed).  This
	//     is also kicked off in the background and may take some time to complete.
	// INPUT: Player message with the 'id' field populated.
	// OUTPUT: Result message denoting success or failure (and an error if
	// necessary)
	DeleteRequest(ctx context.Context, in *Player, opts ...grpc.CallOption) (*Result, error)
	// GetAssignment streams matchmaking results from Open Match for the
	// provided player ID.
	// INPUT: Player message with the 'id' field populated.
	// OUTPUT: a stream of player objects with one or more of the following
	// fields populated, if an update is seen in state storage:
	//  - 'assignment': string that usually contains game server connection information.
	//  - 'status': string to communicate current matchmaking status to the client.
	//  - 'error': string to pass along error information to the client.
	//
	// During normal operation, the expectation is that the player's 'assignment' field
	// will be updated by a Backend process calling the 'CreateAssignments' Backend API
	// endpoint.  'Status' and 'Error' are free for developers to use as they see fit.
	// Even if you had multiple players enter a matchmaking request as a group, the
	// Backend API 'CreateAssignments' call will write the results to state
	// storage separately under each player's ID. OM expects you to make all game
	// clients 'GetAssignment' with their own ID from the Frontend API to get
	// their results.
	//
	// NOTE: This call generates a small amount of load on the Frontend API and state
	//  storage while watching the player record for updates. You are expected
	//  to close the stream from your client after receiving your matchmaking
	//  results (or a reasonable timeout), or you will continue to
	//  generate load on OM until you do!
	// NOTE: Just bear in mind that every update will send egress traffic from
	//  Open Match to game clients! Frugality is recommended.
	GetAssignment(ctx context.Context, in *Player, opts ...grpc.CallOption) (Frontend_GetAssignmentClient, error)
}

type frontendClient struct {
	cc *grpc.ClientConn
}

func NewFrontendClient(cc *grpc.ClientConn) FrontendClient {
	return &frontendClient{cc}
}

func (c *frontendClient) CreateRequest(ctx context.Context, in *Player, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/api.Frontend/CreateRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frontendClient) DeleteRequest(ctx context.Context, in *Player, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/api.Frontend/DeleteRequest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *frontendClient) GetAssignment(ctx context.Context, in *Player, opts ...grpc.CallOption) (Frontend_GetAssignmentClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Frontend_serviceDesc.Streams[0], c.cc, "/api.Frontend/GetAssignment", opts...)
	if err != nil {
		return nil, err
	}
	x := &frontendGetAssignmentClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Frontend_GetAssignmentClient interface {
	Recv() (*Player, error)
	grpc.ClientStream
}

type frontendGetAssignmentClient struct {
	grpc.ClientStream
}

func (x *frontendGetAssignmentClient) Recv() (*Player, error) {
	m := new(Player)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Frontend service

type FrontendServer interface {
	// CreateRequests will put the player (or group, if your 'Player'
	// message represents multiple players) in state storage, and then look
	// through the 'properties' field for the attributes you have defined as
	// indices your matchmaker config.  If the attributes exist and are valid
	// integers, they will be indexed.
	// INPUT: Player message with these fields populated:
	//  - id
	//  - properties
	// OUTPUT: Result message denoting success or failure (and an error if
	// necessary)
	CreateRequest(context.Context, *Player) (*Result, error)
	// DeleteRequest removes the players (or group, if your 'Player'
	// message represents multiple players) from state storage by doing the
	// following:
	//  1) Delete player from configured indices.  This effectively removes the
	//     player from matchmaking when using recommended MMF patterns.
	//     Everything after this is just cleanup to save stage storage space.
	//  2) 'Lazily' delete the player's state storage record.  This is kicked
	//     off in the background and may take some time to complete.
	//  2) 'Lazily' delete the player's metadata indicies (like, the time they
	//     created the request, and the last time the record was accessed).  This
	//     is also kicked off in the background and may take some time to complete.
	// INPUT: Player message with the 'id' field populated.
	// OUTPUT: Result message denoting success or failure (and an error if
	// necessary)
	DeleteRequest(context.Context, *Player) (*Result, error)
	// GetAssignment streams matchmaking results from Open Match for the
	// provided player ID.
	// INPUT: Player message with the 'id' field populated.
	// OUTPUT: a stream of player objects with one or more of the following
	// fields populated, if an update is seen in state storage:
	//  - 'assignment': string that usually contains game server connection information.
	//  - 'status': string to communicate current matchmaking status to the client.
	//  - 'error': string to pass along error information to the client.
	//
	// During normal operation, the expectation is that the player's 'assignment' field
	// will be updated by a Backend process calling the 'CreateAssignments' Backend API
	// endpoint.  'Status' and 'Error' are free for developers to use as they see fit.
	// Even if you had multiple players enter a matchmaking request as a group, the
	// Backend API 'CreateAssignments' call will write the results to state
	// storage separately under each player's ID. OM expects you to make all game
	// clients 'GetAssignment' with their own ID from the Frontend API to get
	// their results.
	//
	// NOTE: This call generates a small amount of load on the Frontend API and state
	//  storage while watching the player record for updates. You are expected
	//  to close the stream from your client after receiving your matchmaking
	//  results (or a reasonable timeout), or you will continue to
	//  generate load on OM until you do!
	// NOTE: Just bear in mind that every update will send egress traffic from
	//  Open Match to game clients! Frugality is recommended.
	GetAssignment(*Player, Frontend_GetAssignmentServer) error
}

func RegisterFrontendServer(s *grpc.Server, srv FrontendServer) {
	s.RegisterService(&_Frontend_serviceDesc, srv)
}

func _Frontend_CreateRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Player)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrontendServer).CreateRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Frontend/CreateRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrontendServer).CreateRequest(ctx, req.(*Player))
	}
	return interceptor(ctx, in, info, handler)
}

func _Frontend_DeleteRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Player)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FrontendServer).DeleteRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Frontend/DeleteRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FrontendServer).DeleteRequest(ctx, req.(*Player))
	}
	return interceptor(ctx, in, info, handler)
}

func _Frontend_GetAssignment_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Player)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FrontendServer).GetAssignment(m, &frontendGetAssignmentServer{stream})
}

type Frontend_GetAssignmentServer interface {
	Send(*Player) error
	grpc.ServerStream
}

type frontendGetAssignmentServer struct {
	grpc.ServerStream
}

func (x *frontendGetAssignmentServer) Send(m *Player) error {
	return x.ServerStream.SendMsg(m)
}

var _Frontend_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Frontend",
	HandlerType: (*FrontendServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRequest",
			Handler:    _Frontend_CreateRequest_Handler,
		},
		{
			MethodName: "DeleteRequest",
			Handler:    _Frontend_DeleteRequest_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetAssignment",
			Handler:       _Frontend_GetAssignment_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/protobuf-spec/frontend.proto",
}

func init() { proto.RegisterFile("api/protobuf-spec/frontend.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 205 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0xcf, 0x31, 0x4b, 0x43, 0x31,
	0x14, 0xc5, 0xf1, 0x16, 0x41, 0x24, 0x50, 0x90, 0x37, 0x76, 0x92, 0xee, 0x7d, 0x11, 0xa5, 0x74,
	0xd6, 0x8a, 0x5d, 0x4b, 0x47, 0xb7, 0x9b, 0xd7, 0xf3, 0xd2, 0x40, 0x92, 0x1b, 0x73, 0x6f, 0x06,
	0x3f, 0x96, 0xdf, 0x50, 0x6c, 0x45, 0x1c, 0x04, 0x71, 0x3d, 0xfc, 0x7f, 0xc3, 0x31, 0x37, 0x54,
	0x82, 0x2d, 0x95, 0x95, 0x5d, 0x1b, 0x97, 0x52, 0x30, 0xd8, 0xb1, 0x72, 0x56, 0xe4, 0x43, 0x7f,
	0x9a, 0xbb, 0x0b, 0x2a, 0x61, 0xfe, 0x4b, 0x96, 0x20, 0x42, 0x1e, 0x72, 0xce, 0xee, 0xde, 0xa7,
	0xe6, 0xea, 0xf9, 0x4b, 0x76, 0x2b, 0x33, 0xdb, 0x54, 0x90, 0x62, 0x8f, 0xd7, 0x06, 0xd1, 0xee,
	0xba, 0xff, 0xce, 0x77, 0x91, 0xde, 0x50, 0xe7, 0x3f, 0x96, 0x3d, 0xa4, 0x45, 0x5d, 0x4c, 0x3e,
	0xd9, 0x13, 0x22, 0xfe, 0xcb, 0xd6, 0x66, 0xb6, 0x85, 0x3e, 0x88, 0x04, 0x9f, 0x13, 0xf2, 0x1f,
	0xec, 0xbc, 0x2c, 0x26, 0xb7, 0xd3, 0xc7, 0xf5, 0xcb, 0xca, 0x07, 0x3d, 0x36, 0xd7, 0x0f, 0x9c,
	0xec, 0x96, 0xd9, 0x47, 0x6c, 0x22, 0xb7, 0xc3, 0x2e, 0x92, 0x8e, 0x5c, 0x93, 0xe5, 0x82, 0xbc,
	0x4c, 0xa4, 0xc3, 0xd1, 0x86, 0xac, 0xa8, 0x99, 0xa2, 0x2d, 0xce, 0x5d, 0x9e, 0x3e, 0xdf, 0x7f,
	0x04, 0x00, 0x00, 0xff, 0xff, 0xb5, 0xc6, 0x9a, 0xe0, 0x3e, 0x01, 0x00, 0x00,
}

/*
package apisrv provides an implementation of the gRPC server defined in ../../../api/protobuf-spec/frontend.proto.

Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

package apisrv

import (
	"context"
	"errors"
	"net"
	"time"

	"github.com/GoogleCloudPlatform/open-match/internal/metrics"
	frontend "github.com/GoogleCloudPlatform/open-match/internal/pb"
	redisHelpers "github.com/GoogleCloudPlatform/open-match/internal/statestorage/redis"
	"github.com/GoogleCloudPlatform/open-match/internal/statestorage/redis/playerindices"
	"github.com/GoogleCloudPlatform/open-match/internal/statestorage/redis/redispb"
	log "github.com/sirupsen/logrus"
	"go.opencensus.io/stats"
	"go.opencensus.io/tag"

	"github.com/gomodule/redigo/redis"
	"github.com/spf13/viper"

	"go.opencensus.io/plugin/ocgrpc"
	"google.golang.org/grpc"
)

// Logrus structured logging setup
var (
	feLogFields = log.Fields{
		"app":       "openmatch",
		"component": "frontend",
		"caller":    "frontendapi/apisrv/apisrv.go",
	}
	feLog = log.WithFields(feLogFields)
)

// FrontendAPI implements frontend.ApiServer, the server generated by compiling
// the protobuf, by fulfilling the frontend.APIClient interface.
type FrontendAPI struct {
	grpc *grpc.Server
	cfg  *viper.Viper
	pool *redis.Pool
}
type frontendAPI FrontendAPI

// New returns an instantiated srvice
func New(cfg *viper.Viper, pool *redis.Pool) *FrontendAPI {
	s := FrontendAPI{
		pool: pool,
		grpc: grpc.NewServer(grpc.StatsHandler(&ocgrpc.ServerHandler{})),
		cfg:  cfg,
	}

	// Add a hook to the logger to auto-count log lines for metrics output thru OpenCensus
	log.AddHook(metrics.NewHook(FeLogLines, KeySeverity))

	// Register gRPC server
	frontend.RegisterFrontendServer(s.grpc, (*frontendAPI)(&s))
	feLog.Info("Successfully registered gRPC server")
	return &s
}

// Open starts the api grpc service listening on the configured port.
func (s *FrontendAPI) Open() error {
	ln, err := net.Listen("tcp", ":"+s.cfg.GetString("api.frontend.port"))
	if err != nil {
		feLog.WithFields(log.Fields{
			"error": err.Error(),
			"port":  s.cfg.GetInt("api.frontend.port"),
		}).Error("net.Listen() error")
		return err
	}
	feLog.WithFields(log.Fields{"port": s.cfg.GetInt("api.frontend.port")}).Info("TCP net listener initialized")

	go func() {
		err := s.grpc.Serve(ln)
		if err != nil {
			feLog.WithFields(log.Fields{"error": err.Error()}).Error("gRPC serve() error")
		}
		feLog.Info("serving gRPC endpoints")
	}()

	return nil
}

// CreateRequest is this service's implementation of the CreateRequest gRPC method defined in frontend.proto
func (s *frontendAPI) CreateRequest(ctx context.Context, group *frontend.Player) (*frontend.Result, error) {

	/*
		// Get redis connection from pool
		redisConn := s.pool.Get()
		defer redisConn.Close()
	*/

	// Create context for tagging OpenCensus metrics.
	funcName := "CreateRequest"
	fnCtx, _ := tag.New(ctx, tag.Insert(KeyMethod, funcName))
	feLog.WithFields(log.Fields{"a": "=========="}).Debug(group)

	// Write group
	err := redispb.MarshalToRedis(ctx, s.pool, group)
	if err != nil {
		feLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
		}).Error("State storage error")

		stats.Record(fnCtx, FeGrpcErrors.M(1))
		return &frontend.Result{Success: false, Error: err.Error()}, err
	}

	// Index group
	err = playerindices.Create(ctx, s.pool, s.cfg, *group)
	if err != nil {
		feLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
		}).Error("State storage error")

		stats.Record(fnCtx, FeGrpcErrors.M(1))
		return &frontend.Result{Success: false, Error: err.Error()}, err
	}

	// Return success.
	stats.Record(fnCtx, FeGrpcRequests.M(1))
	return &frontend.Result{Success: true, Error: ""}, err

}

// DeleteRequest is this service's implementation of the DeleteRequest gRPC method defined in frontend.proto
func (s *frontendAPI) DeleteRequest(ctx context.Context, group *frontend.Player) (*frontend.Result, error) {

	// Create context for tagging OpenCensus metrics.
	funcName := "DeleteRequest"
	fnCtx, _ := tag.New(ctx, tag.Insert(KeyMethod, funcName))

	// Deindex this player; at that point they don't show up in MMFs anymore.  We can then delete
	// their actual player object from Redis later.
	err := playerindices.Delete(ctx, s.pool, s.cfg, group.Id)
	if err != nil {
		feLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
		}).Error("State storage error")

		stats.Record(fnCtx, FeGrpcErrors.M(1))
		return &frontend.Result{Success: false, Error: err.Error()}, err
	}
	// Kick off delete but don't wait for it to complete.
	go s.deletePlayer(group.Id)

	stats.Record(fnCtx, FeGrpcRequests.M(1))
	return &frontend.Result{Success: true, Error: ""}, err

}

// deletePlayer is a 'lazy' player delete, and should only be called after
// confirmation that a player has been deindexed (and therefore nothing can
// find the player to read them anyway)
func (s *frontendAPI) deletePlayer(id string) {

	err := redisHelpers.Delete(context.Background(), s.pool, id)
	if err != nil {
		feLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
		}).Warn("Error deleting player from state storage, this could leak state storage memory but is usually not a fatal error")
	}

}

// GetAssignment is this service's implementation of the GetAssignment gRPC method defined in frontend.proto
//func (s *frontendAPI) GetAssignment(c context.Context, p *frontend.Player) (*frontend.Player, error) {
func (s *frontendAPI) GetAssignment(p *frontend.Player, assignmentStream frontend.Frontend_GetAssignmentServer) error {
	/*
		// Get cancellable context
		ctx, cancel := context.WithCancel(c)
		defer cancel()
	*/
	ctx := assignmentStream.Context()

	// Create context for tagging OpenCensus metrics.
	funcName := "GetAssignment"
	fnCtx, _ := tag.New(ctx, tag.Insert(KeyMethod, funcName))

	// get and return connection string
	watchChan := s.watcher(ctx, s.pool, p.Id) // watcher() runs the appropriate Redis commands.

	for {

		select {
		case <-ctx.Done():
			// Context cancelled
			// TODO: elaborate
			stats.Record(fnCtx, FeGrpcRequests.M(1))
			return nil
		//case <-time.After(30 * time.Second): // TODO: Make this configurable.
		case <-time.After(300 * time.Second): // TODO: Make this configurable.
			err := errors.New("did not see matchmaking results in redis before timeout")
			// TODO:Timeout: deal with the fallout
			// When there is a timeout, need to send a stop to the watch channel.
			// cancelling ctx isn't doing it.
			//cancel()
			feLog.WithFields(log.Fields{
				"error":     err.Error(),
				"component": "statestorage",
				"playerid":  p.Id,
			}).Error("State storage error")

			errTag, _ := tag.NewKey("errtype")
			fnCtx, _ := tag.New(ctx, tag.Insert(errTag, "watch_timeout"))
			stats.Record(fnCtx, FeGrpcErrors.M(1))
			return err

		case a := <-watchChan:
			feLog.Debug(p.Id, "assignment:", a)
			assignmentStream.Send(&frontend.Player{Assignment: a})
			stats.Record(fnCtx, FeGrpcRequests.M(1))
			return nil
		}
	}

}

/*
// DeleteAssignment is this service's implementation of the DeleteAssignment gRPC method defined in frontend.proto
func (s *frontendAPI) DeleteAssignment(c context.Context, p *frontend.Player) (*frontend.Result, error) {

	// Get redis connection from pool
	redisConn := s.pool.Get()
	defer redisConn.Close()

	// Create context for tagging OpenCensus metrics.
	funcName := "DeleteAssignment"
	fnCtx, _ := tag.New(c, tag.Insert(KeyMethod, funcName))

	// Write group
	err := playerq.Delete(redisConn, p.Id)
	if err != nil {
		feLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
		}).Error("State storage error")

		stats.Record(fnCtx, FeGrpcErrors.M(1))
		return &frontend.Result{Success: false, Error: err.Error()}, err
	}

	stats.Record(fnCtx, FeGrpcRequests.M(1))
	return &frontend.Result{Success: true, Error: ""}, err

}
*/

//TODO: Everything below this line will be moved to the redis statestorage library
// in an upcoming version.
// ================================================

// watcher makes a channel and returns it immediately.  It also launches an
// asynchronous goroutine that watches a redis key and returns the value of
// the 'connstring' field of that key once it exists on the channel.
//
// The pattern for this function is from 'Go Concurrency Patterns', it is a function
// that wraps a closure goroutine, and returns a channel.
// reference: https://talks.golang.org/2012/concurrency.slide#25
func (s *frontendAPI) watcher(ctx context.Context, pool *redis.Pool, key string) <-chan string {
	// Add the key as a field to all logs for the execution of this function.
	feLog = feLog.WithFields(log.Fields{"key": key})
	feLog.Debug("Watching key in statestorage for changes")

	watchChan := make(chan string)

	go func() {
		// var declaration
		var results string
		var err = errors.New("haven't queried Redis yet")

		// Loop, querying redis until this key has a value
		for err != nil || results == "" {
			select {
			case <-ctx.Done():
				// Cleanup
				close(watchChan)
				return
			default:
				results, err = s.retrieveConnstring(ctx, pool, key, "assignment")
				if err != nil || results == "" {
					time.Sleep(2 * time.Second) // TODO: exp bo + jitter
				}
			}
		}
		// Return value retreived from Redis asynchonously and tell calling function we're done
		feLog.Debug("Statestorage watched record update detected")
		watchChan <- results
		close(watchChan)
	}()

	return watchChan
}

// retrieveConnstring is a concurrent-safe, context-aware redis HGET of the 'connstring' fieldin the input key
// TODO: This will be moved to the redis statestorage module.
func (s *frontendAPI) retrieveConnstring(ctx context.Context, pool *redis.Pool, key string, field string) (string, error) {

	// Add the key as a field to all logs for the execution of this function.
	feLog = feLog.WithFields(log.Fields{"key": key})

	cmd := "HGET"
	feLog.WithFields(log.Fields{"field": field, "query": cmd}).Debug("Statestorage operation")

	// Get a connection to redis
	redisConn, err := pool.GetContext(ctx)
	defer redisConn.Close()

	// Encountered an issue getting a connection from the pool.
	if err != nil {
		feLog.WithFields(log.Fields{
			"error": err.Error(),
			"query": cmd}).Error("Statestorage connection error")
		return "", err
	}

	// Run redis query and return
	return redis.String(redisConn.Do("HGET", key, field))
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/protobuf-spec/messages.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Open Match's internal representation and wire protocol format for "MatchObjects".
// In order to request a match using the Backend API, your backend code should generate
// a new MatchObject with an ID and properties filled in (for more details about valid
// values for these fields, see the documentation).  Open Match then sends the Match
// Object through to your matchmaking function, where you add players to 'rosters' and
// store any schemaless data you wish in the 'properties' field.  The MatchObject
// is then sent, populated, out through the Backend API to your backend code.
//
// MatchObjects contain a number of fields, but many gRPC calls that take a
// MatchObject as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type MatchObject struct {
	Id         string        `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string        `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Error      string        `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
	Rosters    []*Roster     `protobuf:"bytes,4,rep,name=rosters" json:"rosters,omitempty"`
	Pools      []*PlayerPool `protobuf:"bytes,5,rep,name=pools" json:"pools,omitempty"`
	Status     string        `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
}

func (m *MatchObject) Reset()                    { *m = MatchObject{} }
func (m *MatchObject) String() string            { return proto.CompactTextString(m) }
func (*MatchObject) ProtoMessage()               {}
func (*MatchObject) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *MatchObject) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MatchObject) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *MatchObject) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *MatchObject) GetRosters() []*Roster {
	if m != nil {
		return m.Rosters
	}
	return nil
}

func (m *MatchObject) GetPools() []*PlayerPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *MatchObject) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// Data structure to hold a list of players in a match.
type Roster struct {
	Name    string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Players []*Player `protobuf:"bytes,2,rep,name=players" json:"players,omitempty"`
}

func (m *Roster) Reset()                    { *m = Roster{} }
func (m *Roster) String() string            { return proto.CompactTextString(m) }
func (*Roster) ProtoMessage()               {}
func (*Roster) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *Roster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Roster) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// A 'hard' filter to apply to the player pool.
type Filter struct {
	Name      string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Attribute string `protobuf:"bytes,2,opt,name=attribute" json:"attribute,omitempty"`
	Maxv      int64  `protobuf:"varint,3,opt,name=maxv" json:"maxv,omitempty"`
	Minv      int64  `protobuf:"varint,4,opt,name=minv" json:"minv,omitempty"`
	Stats     *Stats `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *Filter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Filter) GetAttribute() string {
	if m != nil {
		return m.Attribute
	}
	return ""
}

func (m *Filter) GetMaxv() int64 {
	if m != nil {
		return m.Maxv
	}
	return 0
}

func (m *Filter) GetMinv() int64 {
	if m != nil {
		return m.Minv
	}
	return 0
}

func (m *Filter) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Holds statistics
type Stats struct {
	Count   int64   `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	Elapsed float64 `protobuf:"fixed64,2,opt,name=elapsed" json:"elapsed,omitempty"`
}

func (m *Stats) Reset()                    { *m = Stats{} }
func (m *Stats) String() string            { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()               {}
func (*Stats) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

func (m *Stats) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Stats) GetElapsed() float64 {
	if m != nil {
		return m.Elapsed
	}
	return 0
}

// PlayerPools are defined by a set of 'hard' filters, and can be filled in
// with the players that match those filters.
//
// PlayerPools contain a number of fields, but many gRPC calls that take a
// PlayerPool as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type PlayerPool struct {
	Name    string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Filters []*Filter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
	Roster  *Roster   `protobuf:"bytes,3,opt,name=roster" json:"roster,omitempty"`
	Stats   *Stats    `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *PlayerPool) Reset()                    { *m = PlayerPool{} }
func (m *PlayerPool) String() string            { return proto.CompactTextString(m) }
func (*PlayerPool) ProtoMessage()               {}
func (*PlayerPool) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

func (m *PlayerPool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlayerPool) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *PlayerPool) GetRoster() *Roster {
	if m != nil {
		return m.Roster
	}
	return nil
}

func (m *PlayerPool) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Open Match's internal representation and wire protocol format for "Players".
// In order to enter matchmaking using the Frontend API, your client code should generate
// a consistent (same result for each client every time they launch) with an ID and
// properties filled in (for more details about valid values for these fields,
// see the documentation).
// Players contain a number of fields, but the gRPC calls that take a
// Player as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type Player struct {
	Id         string              `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string              `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Pool       string              `protobuf:"bytes,3,opt,name=pool" json:"pool,omitempty"`
	Attributes []*Player_Attribute `protobuf:"bytes,4,rep,name=attributes" json:"attributes,omitempty"`
	Assignment string              `protobuf:"bytes,5,opt,name=assignment" json:"assignment,omitempty"`
	Status     string              `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
	Error      string              `protobuf:"bytes,7,opt,name=error" json:"error,omitempty"`
}

func (m *Player) Reset()                    { *m = Player{} }
func (m *Player) String() string            { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()               {}
func (*Player) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{5} }

func (m *Player) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Player) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Player) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *Player) GetAttributes() []*Player_Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Player) GetAssignment() string {
	if m != nil {
		return m.Assignment
	}
	return ""
}

func (m *Player) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Player) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Player_Attribute struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *Player_Attribute) Reset()                    { *m = Player_Attribute{} }
func (m *Player_Attribute) String() string            { return proto.CompactTextString(m) }
func (*Player_Attribute) ProtoMessage()               {}
func (*Player_Attribute) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{5, 0} }

func (m *Player_Attribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player_Attribute) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Simple message to return success/failure and error status.
type Result struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{6} }

func (m *Result) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// IlInput is an empty message reserved for future use.
type IlInput struct {
}

func (m *IlInput) Reset()                    { *m = IlInput{} }
func (m *IlInput) String() string            { return proto.CompactTextString(m) }
func (*IlInput) ProtoMessage()               {}
func (*IlInput) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{7} }

type Assignments struct {
	Rosters    []*Roster `protobuf:"bytes,1,rep,name=rosters" json:"rosters,omitempty"`
	Assignment string    `protobuf:"bytes,10,opt,name=assignment" json:"assignment,omitempty"`
}

func (m *Assignments) Reset()                    { *m = Assignments{} }
func (m *Assignments) String() string            { return proto.CompactTextString(m) }
func (*Assignments) ProtoMessage()               {}
func (*Assignments) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{8} }

func (m *Assignments) GetRosters() []*Roster {
	if m != nil {
		return m.Rosters
	}
	return nil
}

func (m *Assignments) GetAssignment() string {
	if m != nil {
		return m.Assignment
	}
	return ""
}

// The message for passing in the per-request identifiers
// to a matchmaking function; used so it knows which records to
// write/update in state storage.
type Request struct {
	ProfileId  string `protobuf:"bytes,1,opt,name=profile_id,json=profileId" json:"profile_id,omitempty"`
	ProposalId string `protobuf:"bytes,2,opt,name=proposal_id,json=proposalId" json:"proposal_id,omitempty"`
	RequestId  string `protobuf:"bytes,3,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	ErrorId    string `protobuf:"bytes,4,opt,name=error_id,json=errorId" json:"error_id,omitempty"`
	Timestamp  string `protobuf:"bytes,5,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{9} }

func (m *Request) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *Request) GetProposalId() string {
	if m != nil {
		return m.ProposalId
	}
	return ""
}

func (m *Request) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *Request) GetErrorId() string {
	if m != nil {
		return m.ErrorId
	}
	return ""
}

func (m *Request) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

// The message for passing all the necessary arguments to a
// matchmaking function.
type Arguments struct {
	Request     *Request     `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
	Matchobject *MatchObject `protobuf:"bytes,2,opt,name=matchobject" json:"matchobject,omitempty"`
}

func (m *Arguments) Reset()                    { *m = Arguments{} }
func (m *Arguments) String() string            { return proto.CompactTextString(m) }
func (*Arguments) ProtoMessage()               {}
func (*Arguments) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{10} }

func (m *Arguments) GetRequest() *Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Arguments) GetMatchobject() *MatchObject {
	if m != nil {
		return m.Matchobject
	}
	return nil
}

func init() {
	proto.RegisterType((*MatchObject)(nil), "messages.MatchObject")
	proto.RegisterType((*Roster)(nil), "messages.Roster")
	proto.RegisterType((*Filter)(nil), "messages.Filter")
	proto.RegisterType((*Stats)(nil), "messages.Stats")
	proto.RegisterType((*PlayerPool)(nil), "messages.PlayerPool")
	proto.RegisterType((*Player)(nil), "messages.Player")
	proto.RegisterType((*Player_Attribute)(nil), "messages.Player.Attribute")
	proto.RegisterType((*Result)(nil), "messages.Result")
	proto.RegisterType((*IlInput)(nil), "messages.IlInput")
	proto.RegisterType((*Assignments)(nil), "messages.Assignments")
	proto.RegisterType((*Request)(nil), "messages.Request")
	proto.RegisterType((*Arguments)(nil), "messages.Arguments")
}

func init() { proto.RegisterFile("api/protobuf-spec/messages.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 655 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x6e, 0xd4, 0x3c,
	0x14, 0x55, 0xe6, 0x27, 0x69, 0x6e, 0xa4, 0xef, 0x03, 0xab, 0xa0, 0x50, 0xf1, 0x53, 0x45, 0x42,
	0x1a, 0x15, 0x75, 0x46, 0x1a, 0x54, 0x15, 0xb1, 0x1b, 0x90, 0x80, 0x59, 0x20, 0x2a, 0xb3, 0x82,
	0x0d, 0xf2, 0x24, 0x9e, 0x69, 0x90, 0x13, 0xa7, 0xb6, 0x33, 0x82, 0x47, 0x60, 0xc1, 0x23, 0xb0,
	0xe0, 0x59, 0x78, 0x31, 0xe4, 0xeb, 0x64, 0x12, 0x4a, 0x0b, 0x62, 0xe7, 0x7b, 0xee, 0xb5, 0x7d,
	0xce, 0x3d, 0xd7, 0x86, 0x43, 0x56, 0xe5, 0xb3, 0x4a, 0x49, 0x23, 0x57, 0xf5, 0xfa, 0x58, 0x57,
	0x3c, 0x9d, 0x15, 0x5c, 0x6b, 0xb6, 0xe1, 0x7a, 0x8a, 0x30, 0xd9, 0x6b, 0xe3, 0xe4, 0x87, 0x07,
	0xd1, 0x6b, 0x66, 0xd2, 0xf3, 0x37, 0xab, 0x8f, 0x3c, 0x35, 0xe4, 0x3f, 0x18, 0xe4, 0x59, 0xec,
	0x1d, 0x7a, 0x93, 0x90, 0x0e, 0xf2, 0x8c, 0xdc, 0x07, 0xa8, 0x94, 0xac, 0xb8, 0x32, 0x39, 0xd7,
	0xf1, 0x00, 0xf1, 0x1e, 0x42, 0xf6, 0x61, 0xcc, 0x95, 0x92, 0x2a, 0x1e, 0x62, 0xca, 0x05, 0xe4,
	0x08, 0x02, 0x25, 0xb5, 0xe1, 0x4a, 0xc7, 0xa3, 0xc3, 0xe1, 0x24, 0x9a, 0xdf, 0x98, 0xee, 0x18,
	0x50, 0x4c, 0xd0, 0xb6, 0x80, 0x1c, 0xc1, 0xb8, 0x92, 0x52, 0xe8, 0x78, 0x8c, 0x95, 0xfb, 0x5d,
	0xe5, 0x99, 0x60, 0x9f, 0xb9, 0x3a, 0x93, 0x52, 0x50, 0x57, 0x42, 0x6e, 0x83, 0xaf, 0x0d, 0x33,
	0xb5, 0x8e, 0x7d, 0xbc, 0xae, 0x89, 0x92, 0x57, 0xe0, 0xbb, 0x63, 0x09, 0x81, 0x51, 0xc9, 0x0a,
	0xde, 0x28, 0xc0, 0xb5, 0x65, 0x53, 0xe1, 0x51, 0x56, 0xc0, 0x25, 0x36, 0xee, 0x0e, 0xda, 0x16,
	0x24, 0x5f, 0x3c, 0xf0, 0x5f, 0xe4, 0xe2, 0xba, 0xa3, 0xee, 0x42, 0xc8, 0x8c, 0x51, 0xf9, 0xaa,
	0x36, 0xbc, 0xe9, 0x46, 0x07, 0xd8, 0x1d, 0x05, 0xfb, 0xb4, 0xc5, 0x5e, 0x0c, 0x29, 0xae, 0x11,
	0xcb, 0xcb, 0x6d, 0x3c, 0x6a, 0xb0, 0xbc, 0xdc, 0x92, 0x87, 0x30, 0xb6, 0xc4, 0xad, 0x64, 0x6f,
	0x12, 0xcd, 0xff, 0xef, 0xe8, 0xbc, 0xb5, 0x30, 0x75, 0xd9, 0xe4, 0x14, 0xc6, 0x18, 0xdb, 0x26,
	0xa7, 0xb2, 0x2e, 0x0d, 0x52, 0x19, 0x52, 0x17, 0x90, 0x18, 0x02, 0x2e, 0x58, 0xa5, 0x79, 0x86,
	0x4c, 0x3c, 0xda, 0x86, 0xc9, 0x37, 0x0f, 0xa0, 0x6b, 0xde, 0x75, 0x3d, 0x59, 0xa3, 0xcc, 0x2b,
	0x7a, 0xe2, 0xf4, 0xd3, 0xb6, 0x80, 0x4c, 0xc0, 0x77, 0x66, 0xa1, 0xb0, 0xab, 0xcc, 0x6c, 0xf2,
	0x9d, 0xb0, 0xd1, 0x1f, 0x85, 0x7d, 0x1d, 0x80, 0xef, 0xf8, 0xfd, 0xf3, 0xbc, 0x11, 0x18, 0xd9,
	0x51, 0x68, 0xc6, 0x0d, 0xd7, 0xe4, 0x29, 0xc0, 0xce, 0x83, 0x76, 0xe0, 0x0e, 0x2e, 0x5b, 0x3c,
	0x5d, 0xb4, 0x25, 0xb4, 0x57, 0x6d, 0xef, 0x63, 0x5a, 0xe7, 0x9b, 0xb2, 0xe0, 0xa5, 0x41, 0x3f,
	0x42, 0xda, 0x43, 0xae, 0x9b, 0xb8, 0x6e, 0xee, 0x83, 0xde, 0xdc, 0x1f, 0x9c, 0x40, 0xb8, 0xe8,
	0x4f, 0xc3, 0x6f, 0x6d, 0xdf, 0x87, 0xf1, 0x96, 0x89, 0xda, 0xcd, 0xce, 0x90, 0xba, 0x20, 0x79,
	0x02, 0x3e, 0xe5, 0xba, 0x16, 0xe8, 0xa9, 0xae, 0xd3, 0x94, 0x6b, 0x8d, 0xdb, 0xf6, 0x68, 0x1b,
	0x76, 0x17, 0x0e, 0x7a, 0x17, 0x26, 0x21, 0x04, 0x4b, 0xb1, 0x2c, 0xab, 0xda, 0x24, 0xef, 0x20,
	0x5a, 0xec, 0x78, 0xeb, 0xfe, 0x13, 0xf4, 0xfe, 0xf6, 0x04, 0x7f, 0x6d, 0x02, 0x5c, 0x6e, 0x42,
	0xf2, 0xdd, 0x83, 0x80, 0xf2, 0x8b, 0x9a, 0x6b, 0x43, 0xee, 0xa1, 0x41, 0xeb, 0x5c, 0xf0, 0x0f,
	0x3b, 0xe3, 0xc2, 0x06, 0x59, 0x66, 0xe4, 0x01, 0x44, 0xd6, 0x2d, 0xa9, 0x99, 0xb0, 0xf9, 0x9e,
	0x81, 0x16, 0x5a, 0x66, 0x76, 0xbf, 0x72, 0x47, 0xd9, 0xbc, 0xb3, 0x31, 0x6c, 0x90, 0x65, 0x46,
	0xee, 0xc0, 0x1e, 0x2a, 0xb3, 0xc9, 0x11, 0x26, 0x03, 0x8c, 0x97, 0x99, 0x7d, 0x7b, 0x26, 0x2f,
	0xb8, 0x36, 0xac, 0xa8, 0x1a, 0xa7, 0x3a, 0x20, 0xb9, 0x80, 0x70, 0xa1, 0x36, 0xb5, 0x13, 0xff,
	0x08, 0x82, 0xe6, 0x48, 0x64, 0x18, 0xcd, 0x6f, 0xf6, 0xc4, 0xbb, 0x04, 0x6d, 0x2b, 0xc8, 0x29,
	0x44, 0x85, 0xfd, 0x01, 0x25, 0xfe, 0x80, 0x48, 0x39, 0x9a, 0xdf, 0xea, 0x36, 0xf4, 0xbe, 0x47,
	0xda, 0xaf, 0x7c, 0x76, 0xfa, 0xfe, 0x64, 0x93, 0x9b, 0xf3, 0x7a, 0x35, 0x4d, 0x65, 0x31, 0x7b,
	0x29, 0xe5, 0x46, 0xf0, 0xe7, 0x42, 0xd6, 0xd9, 0x99, 0x60, 0x66, 0x2d, 0x55, 0x31, 0x93, 0x15,
	0x2f, 0x8f, 0x71, 0xcb, 0x2c, 0x2f, 0x0d, 0x57, 0x25, 0x13, 0xb3, 0x6a, 0xb5, 0xf2, 0xf1, 0x17,
	0x7e, 0xfc, 0x33, 0x00, 0x00, 0xff, 0xff, 0x25, 0x28, 0xbd, 0xef, 0xa9, 0x05, 0x00, 0x00,
}
